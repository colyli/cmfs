From: Coly Li <i@coly.li>
Subject: [PATCH] cmfs: mount/umount implementation

This is a very early code for cmfs mount/umount implementation.
Currently this patch just passes gcc compiling, there are
something more to add,
1) imeplent stub routines
2) module_init/exit
3) no journal
4) better text format to all source code files

Signed-off-by: Coly Li <i@coly.li>
---
 fs/cmfs/Kconfig      |    2 +-
 fs/cmfs/Makefile     |   12 +-
 fs/cmfs/cmfs.h       |   18 ++
 fs/cmfs/dcache.c     |   14 +
 fs/cmfs/dcache.h     |    3 +
 fs/cmfs/export.c     |    9 +
 fs/cmfs/journal.c    |   30 ++
 fs/cmfs/localalloc.c |   27 ++
 fs/cmfs/super.c      |  815 ++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/cmfs/sysfile.c    |    7 +
 fs/cmfs/ver.c        |   44 +++
 fs/cmfs/ver.h        |   32 ++
 12 files changed, 1011 insertions(+), 2 deletions(-)

Index: linux-cmfs/fs/cmfs/Makefile
===================================================================
--- linux-cmfs.orig/fs/cmfs/Makefile
+++ linux-cmfs/fs/cmfs/Makefile
@@ -5,4 +5,11 @@ ccflags-y += -DCATCH_BH_JBD_RACES
 obj-$(CONFIG_CMFS_FS) +=	cmfs.o
 
 cmfs-objs := \
-	super.o
+	super.o			\
+	journal.o		\
+	ver.o			\
+	dcache.o		\
+	localalloc.o		\
+	sysfile.o		\
+	inode.o			\
+	journal.o
Index: linux-cmfs/fs/cmfs/cmfs.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/cmfs.h
@@ -0,0 +1,237 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * cmfs.h
+ *
+ * Defines macros and structures used in CMFS.
+ * (Copied and modified from fs/ocfs2/ocfs2.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2012, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+#ifndef CMFS_H
+#define CMFS_H
+
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/rbtree.h>
+#include <linux/kref.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/lockdep.h>
+#include <linux/jbd2.h>
+
+#include "cmfs_fs.h"
+
+#define CMFS_HARD_READONLY	1
+#define CMFS_SOFT_READONLY	0
+
+#define CMFS_CSB_SOFT_RO		0x0001
+#define CMFS_CSB_HARD_RO		0x0002
+#define CMFS_CSB_ERROR_FS		0x0004
+
+#define CMFS_DEFAULT_ATIME_QUANTUM	60
+
+enum cmfs_mount_options {
+	CMFS_MOUNT_BARRIER = 1 << 0,		/* Use block barriers */
+	CMFS_MOUNT_NOINTR = 1 << 1,		/* Don't cache signals */
+	CMFS_MOUNT_ERRORS_PANIC = 1 << 2,	/* Panic on errors */
+	CMFS_MOUNT_DATA_WRITEBACK = 1 << 3,	/* No data ordering */
+	CMFS_MOUNT_INODE64 = 1 << 4,		/* Allow inode numbers > 2^32 */
+	CMFS_MOUNT_COHERENCY_BUFFERED = 1 << 5,	/* Allow concurrent O_DIRECT
+						   writes */
+};
+
+enum cmfs_vol_state {
+	VOLUME_INIT = 0,
+	VOLUME_MOUNTED,
+	VOLUME_DISMOUNTED,
+	VOLUME_DISABLED
+};
+
+
+struct cmfs_alloc_stats {
+	atomic_t moves;
+	atomic_t local_data;
+	atomic_t bitmap_data;
+	atomic_t bg_allocs;
+	atomic_t bg_extends;
+};
+
+enum cmfs_local_alloc_state {
+	CMFS_LA_UNUSED = 0,	/* Local alloc will neber be used for this
+				 * mount point */
+	CMFS_LA_ENABLED,	/* Local alloc is in use */
+	CMFS_LA_THROTLED,	/* Local alloc is in use, but number of
+				 * bits has been reduced */
+	CMFS_LA_DISABLE		/* Local alloc has temporariely been
+				 * disabled */
+};
+
+
+
+struct cmfs_super {
+	struct task_struct *commit_task;
+	struct super_block *sb;
+	struct inode *root_inode;
+	struct inode *sys_root_inode;
+	struct inode *global_system_inodes[NUM_GLOBAL_SYSTEM_INODES];
+	struct inode **local_system_inodes;
+
+	u64 root_blkno;
+	u64 system_dir_blkno;
+	u64 bitmap_blkno;
+	u32 bitmap_cpg;
+	u8 *uuid;
+	char *uuid_str;
+	u32 uuid_hash;
+	u8 *vol_label;
+	u64 first_cluster_group_blkno;
+	u32 fs_generation;
+
+	u32 s_feature_compat;
+	u32 s_feature_incompat;
+	u32 s_feature_ro_compat;
+
+	/*
+	 * Protects s_next_generation, csb_flags.
+	 * Could protect more on csb as it's very short lived.
+	 */
+	spinlock_t csb_lock;
+
+	u32 s_next_generation;
+	unsigned long csb_flags;
+	unsigned long s_mount_opt;
+	unsigned long s_atime_quantum;
+
+	unsigned int max_slots;
+	int slot_num;
+	int s_sectsize_bits;
+	int s_clustersize;
+	int s_clustersize_bits;
+	unsigned int s_xattr_inline_size;
+
+	atomic_t vol_state;
+	struct mutex recovery_lock;
+	struct task_struct *recovery_thread_task;
+	int disable_recovery;
+	wait_queue_head_t checkpoint_event;
+	atomic_t needs_checkpoint;
+	struct cmfs_journal *journal;
+	unsigned long csb_commit_interval;
+
+	struct delayed_work la_enable_wq;
+
+	/*
+	 * Must hold local alloc i_mutex and csb->csb_lock to change
+	 * local_alloc_bits. Reads can be done under either lock
+	 */
+	unsigned int local_alloc_bits;
+	unsigned int local_alloc_default_bits;
+
+	/* protected by csb_lock */
+	enum cmfs_local_alloc_state local_alloc_state;
+
+	struct buffer_head *local_alloc_bh;
+
+	u64 la_last_gd;
+
+	/* for local slot recovery during mount */
+	int dirty;
+	struct cmfs_dinode *local_alloc_copy;
+
+	struct cmfs_alloc_stats alloc_stats;
+	/* "major.minor" of the device */
+	char dev_str[20];
+
+	struct dentry *csb_debug_root;
+	struct dentry *csb_ctxt;
+
+	/* List of dentry locks to release. Anyone can add locks to
+	 * this list, cmfs_sq processes the list */
+	struct cmfs_dentry_lock *dentry_lock_list;
+	struct work_struct dentry_lock_work;
+
+	wait_queue_head_t recovery_event;
+	wait_queue_head_t csb_mount_event;
+
+	/* the group we used to allocate inodes */
+	u64 csb_inode_alloc_group;
+};
+
+#define CMFS_SB(sb)	((struct cmfs_super *)(sb)->s_fs_info)
+
+static inline void cmfs_set_ro_flag(struct cmfs_super *csb,
+				    int flag)
+{
+	int hard;
+
+	hard = (flag == CMFS_HARD_READONLY) ? 1 : 0;
+
+	spin_lock(&csb->csb_lock);
+	csb->csb_flags &= ~(CMFS_CSB_SOFT_RO | CMFS_CSB_HARD_RO);
+	if (hard)
+		csb->csb_flags |= CMFS_CSB_HARD_RO;
+	else
+		csb->csb_flags |= CMFS_CSB_SOFT_RO;
+	spin_unlock(&csb->csb_lock);
+}
+
+static inline int cmfs_is_hard_readonly(struct cmfs_super *csb)
+{
+	int ret;
+	spin_lock(&csb->csb_lock);
+	ret = csb->csb_flags & CMFS_CSB_HARD_RO;
+	spin_unlock(&csb->csb_lock);
+
+	return ret;
+}
+
+static inline u64 cmfs_clusters_to_blocks(struct super_block *sb,
+					  u32 clusters)
+{
+	int c_to_b_bits = CMFS_SB(sb)->s_clustersize_bits -
+		sb->s_blocksize_bits;
+	return (u64)clusters << c_to_b_bits;
+}
+
+static inline u32 cmfs_blocks_to_clusters(struct super_block *sb,
+					  u64 blocks)
+{
+	int b_to_c_bits = CMFS_SB(sb)->s_clustersize_bits -
+		sb->s_blocksize_bits;
+
+	return (u32)(blocks >> b_to_c_bits);
+}
+
+static inline unsigned int cmfs_clusters_to_megabytes(struct super_block *sb,
+						      unsigned int clusters)
+{
+	unsigned int size = clusters << CMFS_SB(sb)->s_clustersize_bits;
+	return (unsigned int)(size >> 20);
+}
+
+static inline unsigned int cmfs_megabytes_to_clusters(struct super_block *sb,
+						      unsigned int megs)
+{
+	unsigned long size = megs << 20;
+	return (unsigned int)(size >> CMFS_SB(sb)->s_clustersize_bits);
+}
+#endif
Index: linux-cmfs/fs/cmfs/dcache.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/dcache.c
@@ -0,0 +1,58 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * dcache.c
+ *
+ * dentry cache handling code
+ * (Copied and modified from fs/ocfs2/dcache.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/namei.h>
+
+#include "cmfs.h"
+#include "dcache.h"
+#include "inode.h"
+
+const struct dentry_operations cmfs_dentry_ops = {
+	.d_revalidate		= NULL,
+	.d_hash			= NULL,
+	.d_compare		= NULL,
+	.d_delete		= NULL,
+	.d_release		= NULL,
+	.d_prune		= NULL,
+	.d_iput			= NULL,
+	.d_dname		= NULL,
+	.d_automount		= NULL,
+	.d_manage		= NULL,
+};
+
+void cmfs_drop_dl_inodes(struct work_struct *work)
+{
+	return;
+}
+
+void cmfs_drop_all_dl_inodes(struct cmfs_super *csb)
+{
+	return;
+}
Index: linux-cmfs/fs/cmfs/dcache.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/dcache.h
@@ -0,0 +1,36 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * dcache.h
+ *
+ * Function prototypes
+ * (Copied and modified from fs/ocfs2/dcache.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_DCACHE_H
+#define CMFS_DCACHE_H
+
+
+extern const struct dentry_operations cmfs_dentry_ops;
+void cmfs_drop_dl_inodes(struct work_struct *work);
+void cmfs_drop_all_dl_inodes(struct cmfs_super *csb);
+
+
+#endif /* CMFS_DCACHE_H */
Index: linux-cmfs/fs/cmfs/journal.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/journal.c
@@ -0,0 +1,111 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * journal.c
+ *
+ * Defines functions of journalling api
+ * (Copied and modified from fs/ocfs2/journal.c)
+ *
+ * Copyright (C) 2003, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/kthread.h>
+#include <linux/time.h>
+#include <linux/random.h>
+
+#include "cmfs.h"
+#include "masklog.h"
+
+static int cmfs_read_journal_inode(struct cmfs_super *csb,
+				   struct buffer_head **bh,
+				   struct inode **ret_inode)
+{
+	return -1;
+}
+
+
+/*
+ * Used for hard readonly access to determine whether jouranl
+ * requires recovery.
+ */
+int cmfs_check_journal(struct cmfs_super *csb)
+{
+	int ret = 0;
+	struct buffer_head *di_bh = NULL;
+	struct cmfs_dinode *di;
+	int journal_dirty = 0;
+
+	ret = cmfs_read_journal_inode(csb, &di_bh, NULL);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	di = (struct cmfs_dinode *)di_bh->b_data;
+	if (le32_to_cpu(di->id1.journal1.ij_flags) &
+	    CMFS_JOURNAL_DIRTY_FL)
+		journal_dirty = 1;
+	brelse(di_bh);
+	di_bh = NULL;
+out:
+	if (journal_dirty)
+		ret = -EROFS;
+	return ret;
+}
+
+void cmfs_complete_recovery(struct work_struct *work)
+{
+	return;
+}
+
+int cmfs_journal_init(struct cmfs_journal *jouranl, int *dirty)
+{
+	*dirty = 1;
+	return 0;
+}
+
+int cmfs_journal_wipe(struct cmfs_journal *journal, int full)
+{
+	return -1;
+}
+
+int cmfs_journal_load(struct cmfs_journal *journal, int replayed)
+{
+	return -1;
+}
+
+void cmfs_journal_shutdown(struct cmfs_super *csb)
+{
+	return;
+}
+
+void cmfs_complete_mount_recovery(struct cmfs_super *csb)
+{
+	return;
+}
+
+void cmfs_recovery_exit(struct cmfs_super *csb)
+{
+	return;
+}
+
Index: linux-cmfs/fs/cmfs/localalloc.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/localalloc.c
@@ -0,0 +1,98 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * localalloc.c
+ *
+ * Local data allocation
+ * (Copied and modified from fs/ocfs2/localalloc.c)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/bitops.h>
+
+#include "masklog.h"
+#include "cmfs.h"
+#include "cmfs_fs.h"
+#include "localalloc.h"
+
+
+unsigned int cmfs_la_default_mb(struct cmfs_super *csb)
+{
+	return 0;
+}
+
+
+
+void cmfs_la_set_sizes(struct cmfs_super *csb, int requested_mb)
+{
+	struct super_block *sb = csb->sb;
+	unsigned int la_default_mb = cmfs_la_default_mb(csb);
+	unsigned int la_max_mb;
+
+	la_max_mb = cmfs_clusters_to_megabytes(sb,
+					      cmfs_local_alloc_size(sb) * 8);
+
+	if (requested_mb == -1) {
+		/* no user request - use defaults */
+		csb->local_alloc_default_bits =
+			cmfs_megabytes_to_clusters(sb, la_default_mb);
+	} else if (requested_mb > la_max_mb) {
+		/* request is too big, we give the maximum available */
+		csb->local_alloc_default_bits =
+			cmfs_megabytes_to_clusters(sb, la_max_mb);
+	} else {
+		csb->local_alloc_default_bits =
+			cmfs_megabytes_to_clusters(sb, requested_mb);
+	}
+
+	csb->local_alloc_default_bits =
+		csb->local_alloc_default_bits;
+}
+
+void cmfs_la_enable_worker(struct work_struct *work)
+{
+	struct cmfs_super *csb =
+		container_of(work, struct cmfs_super,
+			     la_enable_wq.work);
+
+	spin_lock(&csb->csb_lock);
+	csb->local_alloc_state = CMFS_LA_ENABLED;
+	spin_unlock(&csb->csb_lock);
+}
+
+int cmfs_begin_local_alloc_recovery(struct cmfs_super *csb,
+				    struct cmfs_dinode **alloc_copy)
+{
+	return -1;
+}
+
+int cmfs_local_local_alloc(struct cmfs_super *csb)
+{
+	return -1;
+}
+
+void cmfs_shutdown_local_alloc(struct cmfs_super *csb)
+{
+	return;
+}
Index: linux-cmfs/fs/cmfs/super.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/super.c
@@ -0,0 +1,958 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * super.c
+ *
+ * load/unload driver, mount/dismount volumes
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2012, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/random.h>
+#include <linux/statfs.h>
+#include <linux/moduleparam.h>
+#include <linux/blkdev.h>
+#include <linux/parser.h>
+#include <linux/crc32.h>
+#include <linux/mount.h>
+#include <linux/seq_file.h>
+
+#include "masklog.h"
+#include "cmfs.h"
+#include "inode.h"
+#include "sysfile.h"
+#include "dcache.h"
+#include "localalloc.h"
+#include "journal.h"
+
+MODULE_AUTHOR("Coly Li <i@coly.li>");
+MODULE_LICENSE("GPL");
+
+struct mount_options {
+	unsigned long commit_interval;
+	unsigned long mount_opt;
+	unsigned int atime_quantum;
+	signed short slot;
+	int localalloc_opt;
+};
+
+static const struct super_operations cmfs_sops = {
+	.alloc_inode		= NULL,
+	.destroy_inode		= NULL,
+	.dirty_inode		= NULL,
+	.write_inode		= NULL,
+	.drop_inode		= NULL,
+	.evict_inode		= NULL,
+	.put_super		= NULL,
+	.sync_fs		= NULL,
+	.freeze_fs		= NULL,
+	.unfreeze_fs		= NULL,
+	.statfs			= NULL,
+	.remount_fs		= NULL,
+	.umount_begin		= NULL,
+	.show_options		= NULL,
+	.show_devname		= NULL,
+	.show_path		= NULL,
+	.show_stats		= NULL,
+	.bdev_try_to_free_page	= NULL,
+	.nr_cached_objects	= NULL,
+	.free_cached_objects	= NULL,
+};
+
+enum {
+	opt_barrier = 0,
+	opt_err_panic,
+	opt_err_ro,
+	opt_intr,
+	opt_nointr,
+	opt_data_ordered,
+	opt_data_writeback,
+	opt_atime_quantum,
+	opt_commit,
+	opt_localalloc,
+	opt_inode64,
+	opt_coherency_buffered,
+	opt_coherency_full,
+	opt_err,
+};
+
+static const match_table_t tokens = {
+	{opt_barrier, "barrier=%u"},
+	{opt_err_panic, "errors=panic"},
+	{opt_err_ro, "errors=remount-ro"},
+	{opt_intr, "intr"},
+	{opt_nointr, "nointr"},
+	{opt_data_ordered, "data=ordered"},
+	{opt_data_writeback, "data=writeback"},
+	{opt_atime_quantum, "atime_quantum=%u"},
+	{opt_commit, "commit=%u"},
+	{opt_localalloc, "localalloc=%d"},
+	{opt_inode64, "inode64"},
+	{opt_coherency_buffered, "coherency=buffered"},
+	{opt_coherency_full, "coherency=full"},
+	{opt_err, NULL},
+};
+
+static int cmfs_parse_options(struct super_block *sb,
+			     char *options,
+			     struct mount_options *mopt,
+			     int is_remount)
+{
+	int status = 0;
+	int token, option;
+	char *p;
+	substring_t args[MAX_OPT_ARGS];
+
+	mopt->mount_opt = CMFS_MOUNT_NOINTR |
+			  CMFS_MOUNT_INODE64;
+
+	mopt->commit_interval = 0;
+
+	if (!options) {
+		status = 1;
+		goto bail;
+	}
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		if (!(*p))
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case opt_intr:
+			mopt->mount_opt &= ~CMFS_MOUNT_NOINTR;
+			break;
+		case opt_nointr:
+			mopt->mount_opt |= CMFS_MOUNT_NOINTR;
+			break;
+		case opt_err_panic:
+			mopt->mount_opt |= CMFS_MOUNT_ERRORS_PANIC;
+			break;
+		case opt_err_ro:
+			mopt->mount_opt &= ~CMFS_MOUNT_ERRORS_PANIC;
+			break;
+		case opt_data_ordered:
+			mopt->mount_opt &= ~CMFS_MOUNT_DATA_WRITEBACK;
+			break;
+		case opt_data_writeback:
+			mopt->mount_opt |= CMFS_MOUNT_DATA_WRITEBACK;
+			break;
+		case opt_commit:
+			option = 0;
+			if (match_int(&args[0], &option))
+				goto bail;
+			if (option < 0)
+				goto bail;
+			if (option == 0)
+				option = JBD2_DEFAULT_MAX_COMMIT_AGE;
+			mopt->commit_interval = HZ * option;
+			break;
+		case opt_barrier:
+			if (match_int(&args[0], &option))
+				goto bail;
+			if (option)
+				mopt->mount_opt |= CMFS_MOUNT_BARRIER;
+			else
+				mopt->mount_opt &= ~CMFS_MOUNT_BARRIER;
+			break;
+		case opt_coherency_buffered:
+			mopt->mount_opt |= CMFS_MOUNT_COHERENCY_BUFFERED;
+			break;
+		case opt_coherency_full:
+			mopt->mount_opt &= ~CMFS_MOUNT_COHERENCY_BUFFERED;
+			break;
+		default:
+			mlog(ML_ERROR,
+			     "Unrecognized mount option \"%s\" "
+			     "or missing value.\n", p);
+			goto bail;
+		}
+	}
+	status = 1;
+bail:
+	return status;
+}
+
+static int cmfs_verify_volume(struct cmfs_dinode *di,
+			      struct buffer_head *bh,
+			      u32 blksz)
+{
+	int status = -EINVAL;
+
+	if (!memcmp(di->i_signature,
+		   CMFS_SUPER_BLOCK_SIGNATURE,
+		   strlen(CMFS_SUPER_BLOCK_SIGNATURE))) {
+		if ((1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits)) !=
+		    blksz) {
+			mlog(ML_ERROR,
+			     "found superblock with incorrect block size: "
+			     "found %u, should be %u\n",
+			     1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits),
+			     blksz);
+		} else if (le16_to_cpu(di->id2.i_super.s_major_rev_level) !=
+			   CMFS_MAJOR_REV_LEVEL ||
+			   le16_to_cpu(di->id2.i_super.s_minor_rev_level) !=
+			   CMFS_MINOR_REV_LEVEL) {
+			mlog(ML_ERROR,
+			     "found superblock with bad version: "
+			     "found %u.%u, should be %u.%u\n",
+			     le16_to_cpu(di->id2.i_super.s_major_rev_level),
+			     le16_to_cpu(di->id2.i_super.s_minor_rev_level),
+			     CMFS_MAJOR_REV_LEVEL,
+			     CMFS_MINOR_REV_LEVEL);
+		} else if (bh->b_blocknr != le64_to_cpu(di->i_blkno)) {
+			mlog(ML_ERROR,
+			     "bad block number on superblock: "
+			     "found %llu, should be %llu\n",
+			     (unsigned long long)le64_to_cpu(di->i_blkno),
+			     (unsigned long long)bh->b_blocknr);
+		} else if (le32_to_cpu(di->id2.i_super.s_clustersize_bits) <
+			   CMFS_MIN_CLUSTERSIZE_BITS ||
+			   le32_to_cpu(di->id2.i_super.s_clustersize_bits) >
+			   CMFS_MAX_CLUSTERSIZE_BITS) {
+			mlog(ML_ERROR,
+			     "bad cluster size found: %u\n",
+			     1 << le32_to_cpu(
+				  di->id2.i_super.s_clustersize_bits));
+		} else if (!le64_to_cpu(di->id2.i_super.s_root_blkno)) {
+			mlog(ML_ERROR, "bad root_blkno: 0\n");
+		} else if (!le64_to_cpu(di->id2.i_super.s_system_dir_blkno)) {
+			mlog(ML_ERROR, "bad system_dir_blkno: 0\n");
+		} else {
+			status = 0;
+		}
+	}
+
+	if (status)
+		mlog_errno(status);
+	return status;
+}
+
+static int cmfs_get_sector(struct super_block *sb,
+			   struct buffer_head **bh,
+			   int block,
+			   int sect_size)
+{
+	if (!sb_set_blocksize(sb, sect_size)) {
+		mlog(ML_ERROR, "unable to set blocksize\n");
+		return -EIO;
+	}
+
+	*bh = sb_getblk(sb, block);
+	if (!*bh) {
+		mlog_errno(-EIO);
+		return -EIO;
+	}
+	lock_buffer(*bh);
+	ll_rw_block(READ, 1, bh);
+	wait_on_buffer(*bh);
+	if (!buffer_uptodate(*bh)) {
+		mlog_errno(-EIO);
+		brelse(*bh);
+		*bh = NULL;
+		return -EIO;
+	}
+	return 0;
+}
+
+/* probe, load and verify cmfs super block */
+static int cmfs_sb_probe(struct super_block *sb,
+			 struct buffer_head **bh)
+{
+	int status;
+	struct cmfs_dinode *di;
+
+	*bh = NULL;
+	status = cmfs_get_sector(sb,
+				 bh,
+				 CMFS_SUPER_BLOCK_BLKNO,
+				 CMFS_MAX_BLOCKSIZE);
+	if (status < 0) {
+		mlog_errno(status);
+		goto bail;
+	}
+
+	di = (struct cmfs_dinode *)(*bh)->b_data;
+	status = cmfs_verify_volume(di, *bh, CMFS_MAX_BLOCKSIZE);
+	if (status < 0) {
+		brelse(*bh);
+		*bh = NULL;
+	}
+
+bail:
+	return status;
+}
+
+static unsigned long long cmfs_max_file_offset(unsigned int bbits,
+					       unsigned int cbits)
+{
+	unsigned int bytes = 1 << cbits;
+	unsigned int trim = bytes;
+	unsigned int bitshift = 32;
+
+	/*
+	 * i_size and all block offsets in cmfs are always 64 bits
+	 * wide, i_clusters is 32 bits, in cluster_size units. So
+	 * on 64 bit platforms, cluster size will be the limiting
+	 * factor
+	 */
+#if BITS_PER_LONG == 32
+	/* large (2TB+) block devices and files */
+# if defined(CONFIG_LBDAF)
+	BUILD_BUG_ON(sizeof(sector_t) != 8);
+	/*
+	 * We might be limited by page cache size
+	 */
+	if (bytes > PAGE_CACHE_SIZE)
+		bytes = PAGE_CACHE_SIZE;
+# else
+	/*
+	 * We are limited by the size of sector_t. Use block size,
+	 * as that's what we expose to the VFS
+	 */
+	bytes = 1 << bbits;
+# endif
+
+	/*
+	 * shift by 31 here so that we don't get larger
+	 * than MAX_LFS_FILESIZE
+	 */
+	bitshift = 31;
+#endif
+
+	/*
+	 * Trim by a whole cluster when we can actually approcach
+	 * the on-disk limits. Otherwise we can overflow
+	 * i_clusters when an extent start is at the max offset.
+	 */
+	return (((unsigned long long)bytes) << bitshift) - trim;
+}
+
+static int cmfs_setup_csb_uuid(struct cmfs_super *csb,
+			       const unsigned char *uuid,
+			       unsigned uuid_bytes)
+{
+	int i, ret;
+	char *ptr;
+
+	BUG_ON(uuid_bytes != CMFS_VOL_UUID_LEN);
+
+	csb->uuid_str = kzalloc(CMFS_VOL_UUID_LEN * 2 + 1, GFP_KERNEL);
+	if (csb->uuid_str == NULL)
+		return -ENOMEM;
+
+	for (i = 0, ptr = csb->uuid_str; i < CMFS_VOL_UUID_LEN; i++) {
+		/* print with '\0' */
+		ret = snprintf(ptr, 3, "%02X", uuid[i]);
+		if (ret != 2) {
+			/* drop super cleans up */
+			kfree(csb->uuid_str);
+			csb->uuid_str = NULL;
+			return -EINVAL;
+		}
+		/* then only advance past the last char */
+		ptr += 2;
+	}
+
+	return 0;
+}
+
+static void cmfs_release_system_inodes(struct cmfs_super *csb)
+{
+	int i;
+	struct inode *inode;
+
+	for (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {
+		inode = csb->global_system_inodes[i];
+		if (inode) {
+			iput(inode);
+			csb->global_system_inodes[i] = NULL;
+		}
+	}
+
+	inode = csb->sys_root_inode;
+	if (inode) {
+		iput(inode);
+		csb->sys_root_inode = NULL;
+	}
+
+	inode = csb->root_inode;
+	if (inode) {
+		iput(inode);
+		csb->root_inode = NULL;
+	}
+
+	if (!csb->local_system_inodes)
+		return;
+
+	for (i = 0; i < NUM_LOCAL_SYSTEM_INODES; i++) {
+		if (csb->local_system_inodes[i]) {
+			iput(csb->local_system_inodes[i]);
+			csb->local_system_inodes[i] = NULL;
+		}
+	}
+
+	kfree(csb->local_system_inodes);
+	csb->local_system_inodes = NULL;
+}
+
+static int cmfs_init_global_system_inodes(struct cmfs_super *csb)
+{
+	struct inode *new = NULL;
+	int status = 0;
+	int i;
+
+	new = cmfs_iget(csb, csb->root_blkno, CMFS_FI_FLAG_SYSFILE, 0);
+	if (IS_ERR(new)) {
+		status = PTR_ERR(new);
+		goto bail;
+	}
+	csb->root_inode = new;
+
+	new = cmfs_iget(csb, csb->system_dir_blkno, CMFS_FI_FLAG_SYSFILE, 0);
+	if (IS_ERR(new)) {
+		iput(csb->root_inode);
+		csb->root_inode = NULL;
+		status = PTR_ERR(new);
+		goto root_bail;
+	}
+	csb->sys_root_inode = new;
+
+	for (i = CMFS_FIRST_ONLINE_SYSTEM_INODE;
+	     i <= CMFS_LAST_GLOBAL_SYSTEM_INODE;
+	     i++) {
+		new = cmfs_get_system_file_inode(csb, i);
+		if (!new) {
+			cmfs_release_system_inodes(csb);
+			status = -EINVAL;
+			goto sys_root_bail;
+		}
+		iput(new);
+	}
+
+	return status;
+
+sys_root_bail:
+	iput(csb->sys_root_inode);
+root_bail:
+	iput(csb->root_inode);
+bail:
+	mlog_errno(status);
+	return status;
+}
+
+static int cmfs_initialize_super(struct super_block *sb,
+				 struct buffer_head *bh)
+{
+	int status;
+	int i, cbits, bbits;
+	__le32 uuid_net_key;
+	struct cmfs_dinode *di;
+	struct inode *inode = NULL;
+	struct cmfs_journal *journal;
+	struct cmfs_super *csb;
+	u64 total_blocks;
+
+	di = (struct cmfs_dinode *)bh->b_data;
+	csb = kzalloc(sizeof(struct cmfs_super), GFP_KERNEL);
+	if (!csb) {
+		status = -ENOMEM;
+		mlog_errno(status);
+		goto bail;
+	}
+
+	sb->s_fs_info = csb;
+	sb->s_op = &cmfs_sops;
+	sb->s_d_op = &cmfs_dentry_ops;
+	sb->s_time_gran = 1;
+	sb->s_flags |= MS_NOATIME;
+	/* This is needed to support O_LARGEFILE */
+	cbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);
+	bbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);
+	sb->s_maxbytes = cmfs_max_file_offset(bbits, cbits);
+	csb->sb = sb;
+
+	spin_lock_init(&csb->csb_lock);
+
+	atomic_set(&csb->alloc_stats.moves, 0);
+	atomic_set(&csb->alloc_stats.local_data, 0);
+	atomic_set(&csb->alloc_stats.bitmap_data, 0);
+	atomic_set(&csb->alloc_stats.bg_allocs, 0);
+	atomic_set(&csb->alloc_stats.bg_extends, 0);
+
+	snprintf(csb->dev_str, sizeof(csb->dev_str), "%u,%u",
+		MAJOR(csb->sb->s_dev), MINOR(csb->sb->s_dev));
+
+	init_waitqueue_head(&csb->checkpoint_event);
+	atomic_set(&csb->needs_checkpoint, 0);
+
+	csb->s_atime_quantum = CMFS_DEFAULT_ATIME_QUANTUM;
+	csb->slot_num = CMFS_INVALID_SLOT;
+	csb->local_alloc_state = CMFS_LA_UNUSED;
+	csb->local_alloc_bh = NULL;
+	INIT_DELAYED_WORK(&csb->la_enable_wq, cmfs_la_enable_worker);
+	init_waitqueue_head(&csb->csb_mount_event);
+
+	csb->vol_label = kmalloc(CMFS_MAX_VOL_LABEL_LEN, GFP_KERNEL);
+	if (!csb->vol_label) {
+		mlog(ML_ERROR, "unable to alloc vol label\n");
+		status = -ENOMEM;
+		goto bail;
+	}
+
+	csb->s_feature_compat =
+		le32_to_cpu(CMFS_RAW_SB(di)->s_feature_compat);
+	csb->s_feature_ro_compat =
+		le32_to_cpu(CMFS_RAW_SB(di)->s_feature_ro_compat);
+	csb->s_feature_incompat =
+		le32_to_cpu(CMFS_RAW_SB(di)->s_feature_incompat);
+
+	i = CMFS_HAS_INCOMPAT_FEATURE(csb->sb,
+				      ~CMFS_FEATURE_INCOMPAT_SUPP);
+	if (i) {
+		mlog(ML_ERROR,
+		     "couldn't mount because of unsupported optional "
+		     "incompat features (%x).\n", i);
+		status = -EINVAL;
+		goto bail;
+	}
+
+	i =  CMFS_HAS_RO_COMPAT_FEATURE(csb->sb,
+					~CMFS_FEATURE_RO_COMPAT_SUPP);
+	if (!(csb->sb->s_flags & MS_RDONLY) && i) {
+		mlog(ML_ERROR,
+		     "couldn't mount RDWR because of unsupported "
+		     "optional ro_incompat features (%x).\n", i);
+		status = -EINVAL;
+		goto bail;
+	}
+
+	get_random_bytes(&csb->s_next_generation, sizeof(u32));
+
+	/* XXX: FIXME copied from OCFS2 code
+	 * This should be done in ocfs2_journal_init(), but
+	 * unknow ordering issues will cause the filesystem
+	 * to crash. If anyone wants to figure out what part
+	 * of the code referes to osb->journal before
+	 * ocfs2_journal_init() is run, be my guest.
+	 */
+	/* initialize journal structure */
+	journal = kzalloc(sizeof(struct cmfs_journal), GFP_KERNEL);
+	if (!journal) {
+		mlog(ML_ERROR, "unable to alloc journal.\n");
+		status = -ENOMEM;
+		goto bail;
+	}
+	csb->journal = journal;
+	journal->j_csb = csb;
+
+	atomic_set(&journal->j_num_trans, 0);
+	init_rwsem(&journal->j_trans_barrier);
+	init_waitqueue_head(&journal->j_checkpointed);
+	spin_lock_init(&journal->j_lock);
+	journal->j_trans_id = (unsigned long)1;
+	INIT_LIST_HEAD(&journal->j_la_cleanups);
+	INIT_WORK(&journal->j_recovery_work, cmfs_complete_recovery);
+	journal->j_state = CMFS_JOURNAL_FREE;
+
+	INIT_WORK(&csb->dentry_lock_work, cmfs_drop_dl_inodes);
+	csb->dentry_lock_list = NULL;
+
+	/* get some pseudo constants for clustersize bits */
+	csb->s_clustersize_bits =
+		le32_to_cpu(di->id2.i_super.s_clustersize_bits);
+	csb->s_clustersize = 1 << csb->s_clustersize_bits;
+
+	if (csb->s_clustersize < CMFS_MIN_CLUSTERSIZE ||
+	    csb->s_clustersize > CMFS_MAX_CLUSTERSIZE) {
+		mlog(ML_ERROR,
+		     "volume has invalid cluster size (%d)\n",
+		     csb->s_clustersize);
+		status = -EINVAL;
+		goto bail;
+	}
+
+	total_blocks = cmfs_clusters_to_blocks(csb->sb,
+					       le32_to_cpu(di->i_clusters));
+
+	status = generic_check_addressable(csb->sb->s_blocksize_bits,
+					   total_blocks);
+	if (status) {
+		mlog(ML_ERROR,
+		     "volume too large to mount safely on this system");
+		status = -EFBIG;
+		goto bail;
+	}
+
+	if (cmfs_setup_csb_uuid(csb,
+				di->id2.i_super.s_uuid,
+				sizeof(di->id2.i_super.s_uuid))) {
+		mlog(ML_ERROR,
+		     "out of memory trying to setup our uuid.\n");
+		status = -ENOMEM;
+		goto bail;
+	}
+
+	memcpy(&uuid_net_key, di->id2.i_super.s_uuid, sizeof(uuid_net_key));
+
+	strncpy(csb->vol_label, di->id2.i_super.s_label,
+				CMFS_MAX_VOL_LABEL_LEN - 1);
+	csb->vol_label[CMFS_MAX_VOL_LABEL_LEN - 1] = '\0';
+	csb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);
+	csb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);
+	csb->first_cluster_group_blkno =
+		le64_to_cpu(di->id2.i_super.s_first_cluster_group);
+	csb->fs_generation = le32_to_cpu(di->i_fs_generation);
+	csb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);
+	atomic_set(&csb->vol_state, VOLUME_INIT);
+
+	/* load root, system_dir, and all global system inodes */
+	status = cmfs_init_global_system_inodes(csb);
+	if (status < 0) {
+		mlog_errno(status);
+		goto bail;
+	}
+
+	/* global bitmap */
+	inode = cmfs_get_system_file_inode(csb, GLOBAL_BITMAP_SYSTEM_INODE);
+	if (!inode) {
+		status = -EINVAL;
+		mlog_errno(status);
+		goto bail;
+	}
+
+	csb->bitmap_blkno = CMFS_I(inode)->ip_blkno;
+	iput(inode);
+
+	csb->bitmap_cpg = cmfs_group_bitmap_size(sb, 0) * 8;
+
+bail:
+	return status;
+}
+
+
+static int cmfs_init_local_system_inodes(struct cmfs_super *csb)
+{
+	struct inode *new = NULL;
+	int status = 0;
+	int i;
+
+	for (i = CMFS_LAST_GLOBAL_SYSTEM_INODE + 1;
+	     i < NUM_SYSTEM_INODES;
+	     i++) {
+		new = cmfs_get_system_file_inode(csb, i);
+		if (!new) {
+			cmfs_release_system_inodes(csb);
+			status = -EINVAL;
+			mlog(ML_ERROR,
+			     "init system inodes failed: "
+			     "status=%d, sysfile=%d\n",
+			     status, i);
+			goto bail;
+		}
+		/* the array now has one ref, so drop this one */
+		iput(new);
+	}
+bail:
+	if (status)
+		mlog_errno(status);
+	return status;
+}
+
+/*
+ * Make sure entire volume is addressable by our journal.
+ * Not implemented yet.
+ */
+static int cmfs_journal_addressable(struct cmfs_super *csb)
+{
+	return -EINVAL;
+}
+
+static int cmfs_check_volume(struct cmfs_super *csb)
+{
+	int status;
+	int dirty;
+	/* only used if we recover ourselves */
+	struct cmfs_dinode *local_alloc = NULL;
+
+	/* init journal object */
+	status = cmfs_journal_init(csb->journal, &dirty);
+	if (status < 0) {
+		mlog(ML_ERROR, "Could not initialize journal!\n");
+		goto finally;
+	}
+
+	/* journal has been initialized, check to make sure
+	 * entire volume is addressable */
+	status = cmfs_journal_addressable(csb);
+	if (status < 0)
+		goto finally;
+
+	/*
+	 * if the journal was unmounted cleanly then we don't want
+	 * to recover anything. otherwise, journal_load will do
+	 * that dirty work for us.
+	 */
+	if (!dirty) {
+		status = cmfs_journal_wipe(csb->journal, 0);
+		if (status < 0) {
+			mlog_errno(status);
+			goto finally;
+		}
+	} else {
+		printk(KERN_NOTICE "cmfs: File system on device (%s) "
+		       "was not unmounted cleanly, recovering it.\n",
+		       csb->dev_str);
+	}
+
+	/* will play back anything left in journal */
+	status = cmfs_journal_load(csb->journal, dirty);
+	if (status < 0) {
+		mlog(ML_ERROR, "cmfs journal load failed! %d\n", status);
+		goto finally;
+	}
+
+	if (dirty) {
+		/* recover local alloc if we didn't unmount cleanly */
+		status = cmfs_begin_local_alloc_recovery(csb,
+							 &local_alloc);
+		if (status < 0) {
+			mlog_errno(status);
+			goto finally;
+		}
+		/* we complete the recovery process after we've marked
+		 * ourselves as mounted */
+	}
+
+	status = cmfs_load_local_alloc(csb);
+	if (status < 0) {
+		mlog_errno(status);
+		goto finally;
+	}
+
+	if (dirty) {
+		/* recovery will be completed after we've mounted
+		 * the rest of the volume */
+		csb->dirty = 1;
+		csb->local_alloc_copy = local_alloc;
+		local_alloc = NULL;
+	}
+
+finally:
+	kfree(local_alloc);
+	if (status)
+		mlog_errno(status);
+	return status;
+}
+
+static int cmfs_mount_volume(struct super_block *sb)
+{
+	int status = 0;
+	struct cmfs_super *csb = CMFS_SB(sb);
+
+	if (cmfs_is_hard_readonly(csb))
+		goto leave;
+
+	/* load all local system inodes */
+	status = cmfs_init_local_system_inodes(csb);
+	if (status < 0)
+		goto leave;
+
+	status = cmfs_check_volume(csb);
+	if (status < 0)
+		goto leave;
+
+leave:
+	if (status < 0)
+		mlog_errno(status);
+
+	return status;
+}
+
+static void cmfs_delete_csb(struct cmfs_super *csb)
+{
+	/*
+	 * FIXME:
+	 * This belongs in journal shutdown, but because we have to
+	 * allocate csb->journal at the start of cmfs_initialize_csb(),
+	 * we free it here.
+	 */
+	kfree(csb->journal);
+	kfree(csb->local_alloc_copy);
+	kfree(csb->uuid_str);
+	memset(csb, 0, sizeof(struct cmfs_super));
+}
+
+static void cmfs_dismount_volume(struct super_block *sb, int mnt_err)
+{
+	struct cmfs_super *csb = NULL;
+
+	csb = CMFS_SB(sb);
+	BUG_ON(!csb);
+
+	/*
+	 * Flush inode dropping work queue so that deletes
+	 * are performed while the filesystem is stil
+	 * working
+	 */
+	cmfs_drop_all_dl_inodes(csb);
+	cmfs_shutdown_local_alloc(csb);
+	/*
+	 * This will disable recovery and flush andy
+	 * recovery work
+	 */
+	cmfs_recovery_exit(csb);
+	cmfs_journal_shutdown(csb);
+	cmfs_sync_blockdev(sb);
+	cmfs_release_system_inodes(csb);
+	atomic_set(&csb->vol_state, VOLUME_DISMOUNTED);
+
+	printk(KERN_INFO "cmfs: Unmounting device (%s)\n", csb->dev_str);
+
+	cmfs_delete_csb(csb);
+	kfree(csb);
+	sb->s_dev = 0;
+	sb->s_fs_info = 0;
+}
+
+/* core part of mount cmfs */
+static int cmfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct dentry *root;
+	int status;
+	struct mount_options parsed_options;
+	struct inode *inode = NULL;
+	struct cmfs_super *csb = NULL;
+	struct buffer_head *bh = NULL;
+
+	if (!cmfs_parse_options(sb, data, &parsed_options, 0)) {
+		status = -EINVAL;
+		goto read_super_error;
+	}
+
+	status = cmfs_sb_probe(sb, &bh);
+	if (status < 0) {
+		mlog(ML_ERROR, "superblock probe failed!\n");
+		goto read_super_error;
+	}
+
+	status = cmfs_initialize_super(sb, bh);
+	csb = CMFS_SB(sb);
+	if (status < 0) {
+		mlog_errno(status);
+		goto read_super_error;
+	}
+	brelse(bh);
+	bh = NULL;
+
+	csb->s_mount_opt = parsed_options.mount_opt;
+	csb->s_atime_quantum = parsed_options.atime_quantum;
+	csb->csb_commit_interval = parsed_options.commit_interval;
+
+	cmfs_la_set_sizes(csb, parsed_options.localalloc_opt);
+	sb->s_magic = CMFS_SUPER_MAGIC;
+
+	/* hard readonly mode only if: bdev_read_only, MS_RDONLY */
+	if (bdev_read_only(sb->s_bdev)) {
+		if (!(sb->s_flags & MS_RDONLY)) {
+			status = -EACCES;
+			mlog(ML_ERROR,
+			     "Readonly device detected but readonly "
+			     "mount was not specified.\n");
+			goto read_super_error;
+		}
+
+		status = cmfs_check_journal(csb);
+		if (status < 0) {
+			if (status == -EROFS)
+				mlog(ML_ERROR,
+				     "Recovery required on readonly "
+				     "file system, but write access "
+				     "is unavailable.\n");
+			else
+				mlog_errno(status);
+
+			goto read_super_error;
+		}
+
+		cmfs_set_ro_flag(csb, CMFS_HARD_READONLY);
+
+		printk(KERN_NOTICE "cmfs: Readonly device (%s) detected. "
+		       "file system is set to readonly, recovery will be "
+		       "skipped.\n", csb->dev_str);
+	}
+
+	if (!cmfs_is_hard_readonly(csb)) {
+		if (sb->s_flags & MS_RDONLY)
+			cmfs_set_ro_flag(csb, CMFS_SOFT_READONLY);
+	}
+
+	status = cmfs_mount_volume(sb);
+	if (status < 0)
+		goto read_super_error;
+
+	if (csb->root_inode)
+		inode = igrab(csb->root_inode);
+
+	if (!inode) {
+		status = -EIO;
+		mlog_errno(status);
+		goto read_super_error;
+	}
+
+	root = d_make_root(inode);
+	if (!root) {
+		status = -ENOMEM;
+		mlog_errno(status);
+		goto read_super_error;
+	}
+
+	sb->s_root = root;
+
+	cmfs_complete_mount_recovery(csb);
+
+	printk(KERN_INFO "cmfs: Mounting device (%s) with %s data mode.\n",
+	       csb->dev_str,
+	       (csb->s_mount_opt & CMFS_MOUNT_DATA_WRITEBACK) ?
+	       "writeback" : "ordered");
+
+	atomic_set(&csb->vol_state, VOLUME_MOUNTED);
+	wake_up(&csb->csb_mount_event);
+
+	return status;
+
+read_super_error:
+	brelse(bh);
+
+	if (csb) {
+		atomic_set(&csb->vol_state, VOLUME_DISABLED);
+		wake_up(&csb->csb_mount_event);
+		cmfs_dismount_volume(sb, 1);
+	}
+
+	if (status)
+		mlog_errno(status);
+
+	return status;
+}
Index: linux-cmfs/fs/cmfs/sysfile.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/sysfile.c
@@ -0,0 +1,39 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * sysfile.c
+ *
+ * Initialize, read, write, etc. system files.
+ * (Copied and modified from fs/ocfs2/sysfile.c)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modificaiton, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/highmem.h>
+
+#include "cmfs.h"
+#include "masklog.h"
+
+
+struct inode *cmfs_get_system_file_inode(struct cmfs_super *csb, int type)
+{
+	return NULL;
+}
Index: linux-cmfs/fs/cmfs/ver.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/ver.c
@@ -0,0 +1,44 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * ver.c
+ *
+ * version string
+ * (Copied and modified from fs/cofs2/ver.c)
+ *
+ * Copyright (C) 2002, 2005 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#include "ver.h"
+
+#define CMFS_BUILD_VERSION "0.1"
+
+#define VERSION_STR "CMFS " CMFS_BUILD_VERSION
+
+void cmfs_print_version(void)
+{
+	printk(KERN_INFO "%s\n", VERSION_STR);
+}
+
+MODULE_DESCRIPTION(VERSION_STR);
+
+MODULE_VERSION(CMFS_BUILD_VERSION);
Index: linux-cmfs/fs/cmfs/ver.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/ver.h
@@ -0,0 +1,32 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * ver.h
+ *
+ * Function prototypes
+ * (Copied and modified from fs/ocfs2/ver.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_VER_H
+#define CMFS_VER_H
+
+void cmfs_print_version(void);
+
+#endif /* CMFS_VER_H */
Index: linux-cmfs/fs/cmfs/cmfs_fs.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/cmfs_fs.h
@@ -0,0 +1,572 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * cmfs_fs.h
+ * (Copied and modified from fs/ocfs2/ocfs2_fs.h)
+ *
+ * On-disk structures for CMFS.
+ *
+ * Copyright (C) 2002, 2004 Oracle. All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License, version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_FS_H
+#define CMFS_FS_H
+
+/* Version */
+#define CMFS_MAJOR_REV_LEVEL		0
+#define CMFS_MINOR_REV_LEVEL		1
+
+/* XXX: currently hard code to 1 */
+#define CMFS_PER_CPU_NUM		1
+/*
+ * A CMFS volume starts this way:
+ * Sector 0: Valid cmfs_vol_disk_hdr
+ * Sector 1: Valid cmfs_vol_label
+ * Block CMFS_SUPER_BLOCK_BLKNO: CMFS superblock
+ *
+ * All other structures are found from the superblock information.
+ *
+ * CMFS_SUPER_BLOCK_BLKNO is in blocks other than sectors, it is
+ * 4096 bytes into disk/partition.
+ */
+#define CMFS_SUPER_BLOCK_BLKNO		2
+
+#define CMFS_MAX_VOL_SIGNATURE_LEN	128
+#define CMFS_MAX_MOUNT_POINT_LEN	128
+#define CMFS_MAX_VOL_LABEL_LEN		 64
+#define CMFS_MAX_VOL_ID_LENGTH		 16
+#define CMFS_VOL_UUID_LEN		 16
+#define CMFS_MAX_FILENAME_LEN		255
+
+/* Slot map indicator for an empty slot */
+#define CMFS_INVALID_SLOT		-1
+#define CMFS_MAX_SLOTS			255
+
+/* Journal flags (cmfs_dinode.id1.journal1.i_flags) */
+#define CMFS_JOURNAL_DIRTY_FL	(0x00000001)	/* Journal needs recovery */
+
+/*
+ * Min block size = Max block size = 4KB
+ * Min cluster size: 4KB
+ * Max cluster size: 32MB
+ */
+#define CMFS_MIN_CLUSTERSIZE		4096
+#define CMFS_MIN_CLUSTERSIZE_BITS	12
+#define CMFS_MAX_CLUSTERSIZE		(32*(1<<20))
+#define CMFS_MAX_CLUSTERSIZE_BITS	25
+#define CMFS_DEFAULT_CLUSTERSIZE	(1<<20)
+#define CMFS_MAX_BLOCKSIZE		CMFS_MIN_CLUSTERSIZE
+#define CMFS_MIN_BLOCKSIZE		CMFS_MAX_BLOCKSIZE
+
+/* Filesystem magic number
+ * ASCII code of CMFS is 103(0x67), 115(0x73), 106(0x6a), 123(0x7b) */
+#define CMFS_SUPER_MAGIC	0x67736a7b
+
+/* Signature strings */
+#define CMFS_SUPER_BLOCK_SIGNATURE	"CMFSV1"
+#define CMFS_INODE_SIGNATURE		"INODE01"
+#define CMFS_EXTENT_BLOCK_SIGNATURE	"EXBLK01"
+#define CMFS_GROUP_DESC_SIGNATURE	"GROUP01"
+#define CMFS_DIR_TRAILER_SIGNATURE	"DIRTRL1"
+
+/*
+ * Flags on cmfs_dinode.i_flags
+ */
+#define CMFS_VALID_FL		(0x00000001)	/* Inode is valid */
+#define CMFS_UNUSED1_FL		(0x00000002)
+#define CMFS_ORPHANED_FL	(0x00000004)	/* On the orphan list */
+#define CMFS_UNUSED2_FL		(0x00000008)
+/* System inode flags */
+#define CMFS_SYSTEM_FL		(0x00000010)	/* System inode */
+#define CMFS_SUPER_BLOCK_FL	(0x00000020)	/* Super block */
+#define CMFS_LOCAL_ALLOC_FL	(0x00000040)	/* Slot local alloc bitmap */
+#define CMFS_BITMAP_FL		(0x00000080)	/* Allocation bitmap */
+#define CMFS_JOURNAL_FL		(0x00000100)	/* Journal */
+#define CMFS_CHAIN_FL		(0x00000200)	/* Chain allocator */
+#define CMFS_DEALLOC_FL		(0x00000400)	/* Truncate log */
+
+/*
+ * Flags on cmfs_dinode.i_dyn_features
+ *
+ * These can change much more often than i_flags. When adding
+ * flags, keep in mind that i_dyn_features in only 16 bits
+ * wide.
+ *
+ * XXX: Currently most of them will not be supported
+ */
+#define CMFS_INLINE_DATA_FL	(0x0001)	/* Data stored in inode block */
+#define CMFS_HAS_XATTR_FL	(0x0002)
+#define CMFS_INLINE_XATTR_FL	(0x0004)
+#define CMFS_INDEXED_DIR_FL	(0x0008)
+#define CMFS_HAS_REFCOUNT_FL	(0x0010)
+
+/*
+ * CMFS directory file types. Only the low 3 bits are used.
+ * The other bits are reserved now
+ */
+#define CMFS_FT_UNKNOWN		0
+#define CMFS_FT_REG_FILE	1
+#define CMFS_FT_DIR		2
+#define CMFS_FT_CHRDEV		3
+#define CMFS_FT_BLKDEV		4
+#define CMFS_FT_FIFO		5
+#define CMFS_FT_SOCK		6
+#define CMFS_FT_SYMLINK		7
+
+#define CMFS_FT_MAX		8
+
+/*
+ * Directory entry related stuffs
+ *
+ * CMFS_DIR_PAD defines the directory entries boundaries
+ * Note: it must be a multiple of 4
+ */
+#define CMFS_DIR_PAD			4
+#define CMFS_DIR_ROUND			(CMFS_DIR_PAD - 1)
+#define CMFS_DIR_MEMBER_LEN		offsetof(struct cmfs_dir_entry, name)
+#define CMFS_DIR_REC_LEN(name_len)	(((name_len) + CMFS_DIR_MEMBER_LEN + \
+					  CMFS_DIR_ROUND) & \
+					 ~CMFS_DIR_ROUND)
+#define CMFS_DIR_MIN_REC_LEN		CMFS_DIR_REC_LEN(1)
+
+#define CMFS_LINK_MAX		32000
+#define CMFS_DX_LINK_MAX	((1U<<31) - 1U)
+#define CMFS_LINKS_HI_SHIFT	16
+#define CMFS_DX_ENTRIES_MAX	(0xffffffffU)
+
+
+#define CMFS_RAW_SB(dinode)	(&((dinode)->id2.i_super))
+#define CMFS_HAS_COMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_compat & (mask))
+#define CMFS_HAS_RO_COMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_ro_compat & (mask))
+#define CMFS_HAS_INCOMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_incompat & (mask))
+#define CMFS_SET_COMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_compat |= (mask))
+#define CMFS_SET_RO_COMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_ro_compat |= (mask))
+#define CMFS_SET_INCOMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_incompat |= (mask))
+#define CMFS_CLEAR_COMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_compat &= ~(mask))
+#define CMFS_CLEAR_RO_COMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_ro_compat &= ~(mask))
+#define CMFS_CLEAR_INCOMPAT_FEATURE(sb, mask)		\
+	(CMFS_SB(sb)->s_feature_incompat &= ~(mask))
+
+
+/* Compatibility flags */
+#define CMFS_FEATURE_COMPAT_BACKUP_SB		0x0001
+#define CMFS_FEATURE_COMPAT_JBD2_SB		0x0002
+#define CMFS_FEATURE_COMPAT_INLINE_DATA		0x0004
+#define CMFS_FEATURE_COMPAT_META_ECC		0x0008
+#define CMFS_FEATURE_COMPAT_INDEXED_DIRS	0x0010
+#define CMFS_FEATURE_COMPAT_REFCOUNT_TREE	0x0020
+#define CMFS_FEATURE_COMPAT_UNWRITTEN		0x0040
+#define CMFS_FEATURE_COMPAT_TUNEFS_INPROG	0x0080
+#define CMFS_FEATURE_COMPAT_RESIZE_INPROG	0x0100
+
+
+#define CMFS_FEATURE_COMPAT_SUPP	(CMFS_FEATURE_COMPAT_BACKUP_SB \
+					 | CMFS_FEATURE_COMPAT_JBD2_SB \
+					 | CMFS_FEATURE_COMPAT_INLINE_DATA \
+					 | CMFS_FEATURE_COMPAT_META_ECC \
+					 | CMFS_FEATURE_COMPAT_INDEXED_DIRS \
+					 | CMFS_FEATURE_COMPAT_REFCOUNT_TREE \
+					 | CMFS_FEATURE_COMPAT_UNWRITTEN)
+#define CMFS_FEATURE_INCOMPAT_SUPP	0x0
+#define CMFS_FEATURE_RO_COMPAT_SUPP	0x0
+
+/* System file index */
+enum {
+	BAD_BLOCK_SYSTEM_INODE = 0,
+	GLOBAL_INODE_ALLOC_SYSTEM_INODE,
+#define CMFS_FIRST_ONLINE_SYSTEM_INODE GLOBAL_INODE_ALLOC_SYSTEM_INODE
+	GLOBAL_BITMAP_SYSTEM_INODE,
+#define CMFS_LAST_GLOBAL_SYSTEM_INODE GLOBAL_BITMAP_SYSTEM_INODE
+/*	ORPHAN_DIR_SYSTEM_INODE, */
+#define CMFS_FIRST_LOCAL_SYSTEM_INODE EXTENT_ALLOC_SYSTEM_INODE
+	EXTENT_ALLOC_SYSTEM_INODE,
+	INODE_ALLOC_SYSTEM_INODE,
+	JOURNAL_SYSTEM_INODE,
+	LOCAL_ALLOC_SYSTEM_INODE,
+	TRUNCATE_LOG_SYSTEM_INODE,
+#define CMFS_LAST_LOCAL_SYSTEM_INODE TRUNCATE_LOG_SYSTEM_INODE
+	NUM_SYSTEM_INODES
+};
+#define NUM_GLOBAL_SYSTEM_INODES CMFS_FIRST_LOCAL_SYSTEM_INODE
+#define NUM_LOCAL_SYSTEM_INODES \
+		(NUM_SYSTEM_INODES - CMFS_FIRST_LOCAL_SYSTEM_INODE)
+
+/*
+ * CMFS volume header, lives at sector 0.
+ */
+struct cmfs_vol_disk_hdr {
+	u8 signature[CMFS_MAX_VOL_SIGNATURE_LEN];
+	u8 mount_point[CMFS_MAX_MOUNT_POINT_LEN];
+};
+
+/*
+ * CMFS volume label, lives at sector 1.
+ */
+struct cmfs_vol_label {
+	u8	label[CMFS_MAX_VOL_LABEL_LEN];
+	__le16	label_len;
+	u8	vol_id[CMFS_MAX_VOL_ID_LENGTH];
+	__le16	vol_id_len;
+};
+
+/*
+ * Block checking structure. This is used in metadata to validate the
+ * contents. If CMFS_FEATURE_INCOMPAT_META_ECC is not set, it is all
+ * zeros.
+ */
+struct cmfs_block_check {
+/*00*/	__le32 bc_crc32e;
+	__le16 bc_ecc;
+	__le16 bc_reserved1;
+/*08*/
+};
+
+/*
+ * On disk extent record for CMFS
+ * It describes a range of blocks on disk.
+ *
+ * Length fields are devided into interior and leaf node version.
+ * This leaves room for a flags field (CMFS_EXT_*) in the leaf nodes.
+ */
+struct cmfs_extent_rec {
+/*00*/	__le64 e_cpos;		/* Offset into the file, in clusters */
+/*08*/	__le64 e_blkno;		/* Physical disk offset, in blocks */
+/*10*/	union {
+		__le64 e_int_clusters;	/* Clusters covered by all children */
+/*		__le64 e_int_blocks;	/* blocks covered by all children */
+		struct {
+			__le32 e_leaf_blocks;	/* blocks covered by this extent
+						   for 4KB block, the max length
+						   of single extent is 16TB */
+			u8	e_flags;	/* extent flags */
+			u8	e_reserved1;
+			__le16	e_reserved2;
+			__le64	e_reserved3;
+		};
+	};
+/*20*/
+};
+
+/*
+ * On disk extent list for CMFS (node in teh tree). Note that this
+ * is contained inside cmfs_dinode or cmfs_extent_block, so the
+ * offsets are relative to cmfs_dinode.id2.i_list or
+ * cmfs_extent_block.h_list, respectively.
+ */
+struct cmfs_extent_list {
+/*00*/	__le16 l_tree_depth;	/* Extent tree depth from this point.
+				   0 means data extents hang directly
+				   off this header (a leaf)
+				   NOTE: the high 8 bits cannot be
+				   used - tree_depth is never that big.
+				 */
+	__le16 l_count;		/* Number of extent records */
+	__le16 l_next_free_rec;	/* Next unused extent slot */
+	__le16 l_reserved1;
+/*10*/	__le64 l_reserved2[3];	/* Pad to sizeof(cmfs_extent_rec) */
+/*20*/	struct cmfs_extent_rec l_recs[0];	/* Extent records */
+};
+
+/*
+ * On disk chain record format within chain list for CMFS.
+ */
+struct cmfs_chain_rec {
+/*00*/	__le32 c_free;	/* Number of free bits in this chain */
+	__le32 c_total;	/* Number of total bits in this chain */
+	__le64 c_blkno;	/* Physical disk offset (blocks) of 1st group */
+/*10*/
+};
+
+/*
+ * On disk allocation chain list for CMFS. Note that this is
+ * contained inside cmfs_inode, so the offsets are relative to
+ * cmfs_dinode.id2.i_chain.
+ */
+struct cmfs_chain_list {
+/*00*/	__le16 cl_cpg;			/* Clusters per Block Group */
+	__le16 cl_bpc;			/* Bits per Cluster */
+	__le16 cl_count;		/* Total chains in this list */
+	__le16 cl_next_free_rec;	/* Next unused chain slot */
+	__le64 cl_reserved1;
+/*10*/	struct cmfs_chain_rec cl_recs[0];	/* Chain records */
+};
+
+/*
+ * Local allocation bitmap for CMFS per-cpu slots
+ * Note that it exists inside cmfs_dinode, so all offsets
+ * are relative to the start of cmfs_dinode.id2.
+ */
+struct cmfs_local_alloc {
+/*00*/	__le32 la_bm_off;	/* Starting bit offset in main bitmap */
+	__le16 la_size;		/* Size of included bitmap, in bytes */
+	__le16 la_reserved1[5];
+/*10*/	u8	la_bitmap[0];
+};
+
+/*
+ * On disk truncate record format for truncate log
+ */
+struct cmfs_truncate_rec {
+	__le32 t_start;		/* 1st cluster in this log */
+	__le32 t_clusters;	/* Number of total clusters convered */
+};
+
+/*
+ * On disk deallocation log for CMFS. Note that this is
+ * contained inside cmfs_dinode, so the offsets are
+ * relative to cmfs_dinode.id2.i_dealloc.
+ */
+struct cmfs_truncate_log {
+/*00*/	__le16 tl_count;			/* Total records in this log*/
+	__le16 tl_used;				/* Number of records in use*/
+	__le16 tl_reserved1[6];
+/*10*/	struct cmfs_truncate_rec tl_recs[0];	/* Truncate records */
+};
+
+/*
+ * Data-in-inode header. This is only used for i_dyn_features
+ * has CMFS_INLINE_DATA_FL set
+ */
+struct cmfs_inline_data {
+/*00*/	__le16	id_count;	/* Number of bytes can be used for data,
+				   starting at id_data */
+	__le16	id_reserved1[3];
+/*08*/	u8	id_data[0];	/* Start of user data */
+};
+
+/*
+ * On disk superblock for CMFS
+ * Note that it is contained inside cmfs_dinode, so all offsets
+ * are relative to the start of cmfs_dinode.id2.
+ */
+struct cmfs_super_block {
+/*00*/	__le16	s_major_rev_level;
+	__le16	s_minor_rev_level;
+	__le16	s_mnt_count;
+	__le16	s_max_mnt_count;
+	__le16	s_state;
+	__le16	s_errors;
+	__le32	s_checkinterval;
+/*10*/	__le64	s_lastcheck;
+	__le32	s_creator_os;
+	__le32	s_feature_compat;
+/*20*/	__le32	s_feature_incompat;
+	__le32	s_feature_ro_compat;
+	__le64	s_root_blkno;
+/*30*/	__le64	s_system_dir_blkno;
+	__le32	s_blocksize_bits;
+	__le32	s_clustersize_bits;
+/*40*/	u8	s_label[CMFS_MAX_VOL_LABEL_LEN];
+/*80*/	u8	s_uuid[CMFS_VOL_UUID_LEN];
+/*90*/	__le16	s_tunefs_flag;
+	__le16	s_xattr_inline_size;
+	__le32	s_uuid_hash;
+	__le64	s_first_cluster_group;
+/*A0*/
+/*
+ * XXXX: should pad all rest space of dinode which contains the super
+ * block to zero
+ */
+};
+
+/*
+ * On disk CMFS inode format
+ */
+struct cmfs_dinode {
+/*00*/	u8	i_signature[8];		/* Signature for validation */
+	__le32	i_generation;		/* Generation number */
+	__le32	i_links_count;		/* Links count */
+/*10*/	__le32	i_uid;			/* Owner UID */
+	__le32	i_gid;			/* Owner GID */
+	__le64	i_size;
+/*20*/	__le64	i_atime;
+	__le64	i_ctime;
+/*30*/	__le64	i_mtime;
+	__le64	i_dtime;
+/*40*/	__le32	i_flags;
+	__le16	i_mode;
+	__le16	i_suballoc_slot;		/* Slot suballocator this inode
+					   belongs to */
+	__le64	i_blkno;
+/*50*/	__le32	i_clusters;		/* Cluster count */
+	__le32	i_fs_generation;
+	__le64	i_last_eb_blk;
+/*60*/	__le32	i_atime_nsec;
+	__le32	i_ctime_nsec;
+	__le32	i_mtime_nsec;
+	__le32	i_attr;
+/*70*/	__le64	i_xattr_loc;
+	__le64	i_refcount_loc;
+/*80*/	__le64	i_suballoc_loc;
+/*88*/ struct cmfs_block_check i_check;
+/*90*/	__le16	i_dyn_features;
+	__le16	i_xattr_inline_size;
+	/* XXX: will move it to the location after i_suballoc_slot */
+	__le16	i_suballoc_bit;
+	__le16	i_reserved1[1];
+/*98*/	union {
+		__le64 i_pad1;
+		struct {
+			__le64 i_rdev;	/* Raw device number */
+		} dev1;
+		struct {
+			__le32 i_used;
+			__le32 i_total;
+		} bitmap1;
+		struct {
+			__le32 ij_flags;
+			__le32 ij_recovery_generation;
+		} journal1;
+	} id1;
+/*A0*/ union {
+		struct cmfs_super_block		i_super;
+		struct cmfs_local_alloc		i_lab;
+		struct cmfs_chain_list		i_chain;
+		struct cmfs_extent_list		i_list;
+		struct cmfs_truncate_log	i_dealloc;
+		struct cmfs_inline_data		i_data;
+		u8				i_symlink[0];
+	} id2;
+/* Actual on-disk size is one block (4KB) */
+
+};
+
+/*
+ * On disk directory entry structure for CMFS
+ *
+ * Packed as this structure is variable size and accessed
+ * unsligned on 32/64-bit platform
+ */
+struct cmfs_dir_entry {
+/*00*/	__le64	inode;				/* Inode number */
+	__le16	rec_len;			/* Directory entry length */
+	u8	name_len;			/* Name length */
+	u8	file_type;
+/*0c*/	char name[CMFS_MAX_FILENAME_LEN];	/* File name */
+/* Actual on-disk length specified by rec_len */
+} __packed;
+
+/*
+ * Per-block record for the unindexed directry btree.
+ * This is carefully crafted so that the rec_len and name_len records
+ * of a cmfs_dir_entry are mirrored. That way, the directory manipulation
+ * code needs a minial amount of update.
+ *
+ * NOTE: Keep this structure aligned to a multiple of 4 bytes.
+ */
+struct cmfs_dir_block_trailer {
+/*00*/	__le64	db_compat_inode;	/* Always zero. Was inode */
+	__le16	db_compat_rec_len;	/* Backwards compatible with
+					   cmfs_dir_entry */
+	u8	db_compat_name_len;	/* Always zero. Was name_len */
+	u8	db_reserved0;
+	__le16	db_reserved1;
+	__le16	db_free_rec_len;	/* Size of largest empty hole
+					   in this block. */
+/*10*/	u8	db_signature[8];	/* Signature for verification */
+	__le64	db_reserved2;
+/*20*/	__le64	db_free_next;		/* Next block in list */
+	__le64	db_blkno;		/* Offset o disk, in blocks */
+/*30*/	__le64	db_parent_dinode;	/* dinode which owns me, in
+					   blocks */
+	__le64	db_reserved3;
+/*40*/	struct cmfs_block_check db_check; /* Error checking */
+};
+
+/*
+ * Largest bigmap for a block (suballocator) group in bytes.
+ * This limit does not affect cluster groups (global allocator).
+ * Cluster group bitmaps run to the end of the block.
+ */
+#define CMFS_MAX_BG_BITMAP_SIZE		256
+/*
+ * On disk allocator group structure for CMFS
+ */
+struct cmfs_group_desc {
+/*00*/	u8	bg_signature[8];	/* Signature for validation */
+	__le16	bg_size;		/* Size of included bitmap in bytes */
+	__le16	bg_bits;		/* Bits represented by this group */
+	__le16	bg_free_bits_count;	/* Free bits count */
+	__le16	bg_chain;		/* What chain I am in */
+/*10*/	__le32	bg_generation;
+	__le32	bg_reserved1;
+	__le64	bg_next_group;		/* Next group in my list, in blocks */
+/*20*/	__le64	bg_parent_dinode;	/* dinode which owns me, in blocks */
+	__le64	bg_blkno;		/* Where desc stored on disk, in
+					   blocks */
+/*30*/	struct cmfs_block_check bg_check;
+	__le64	bg_reserved2;
+/*40*/	union {
+		u8	bg_bitmap[0];
+		struct {
+/* XXX: remove this latter ? */
+			u8	bg_bitmap_filler[CMFS_MAX_BG_BITMAP_SIZE];
+/*140*/			struct cmfs_extent_list bg_list;
+		};
+	};
+/* Actual on-disk size is one block */
+};
+
+
+
+#ifdef __KERNEL__
+static inline int cmfs_group_bitmap_size(struct super_block *sb,
+					 int suballocator)
+{
+	int size = sb->s_blocksize -
+		offsetof(struct cmfs_group_desc, bg_bitmap);
+
+	return size;
+}
+
+static inline u16 cmfs_local_alloc_size(struct super_block *sb)
+{
+	u16 size;
+	size = sb->s_blocksize -
+		offsetof(struct cmfs_dinode, id2.i_lab.la_bitmap);
+	return size;
+}
+#else
+static inline int cmfs_group_bitmap_size(int blocksize,
+					 int suballocator)
+{
+	int size = blocksize -
+		offsetof(struct cmfs_group_desc, bg_bitmap);
+
+	return size;
+}
+
+static inline int cmfs_local_alloc_size(int blocksize)
+{
+	int size;
+	size = blocksize -
+		offsetof(struct cmfs_dinode, id2.i_lab.la_bitmap);
+
+	return size;
+}
+#endif /* __KERNEL__ */
+
+#endif /* CMFS_FS_H */
Index: linux-cmfs/fs/cmfs/inode.c
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/inode.c
@@ -0,0 +1,49 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * inode.c
+ *
+ * vfs' aops, fops, dops and iops
+ * (Copied and modified from fs/ocfs2/inode.c)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <linux/quotaops.h>
+
+#include <asm/byteorder.h>
+
+#include "cmfs.h"
+
+struct inode *cmfs_iget(struct cmfs_super *csb,
+			u64 blkno,
+			unsigned flags,
+			int sysfile_type)
+{
+	return NULL;
+}
+
+void cmfs_sync_blockdev(struct super_block *sb)
+{
+	sync_blockdev(sb->s_bdev);
+}
Index: linux-cmfs/fs/cmfs/inode.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/inode.h
@@ -0,0 +1,55 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * inode.h
+ *
+ * Function prototypes
+ * (Copied and modified from fs/ocfs2/inode.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_INODE_H
+#define CMFS_INODE_H
+
+/* CMFS Inode Private Data */
+struct cmfs_inode_info {
+	u64		ip_blkno;
+	struct inode	vfs_inode;
+};
+
+
+/* Flags for cmfs_iget() */
+#define CMFS_FI_FLAG_SYSFILE		0x1
+#define CMFS_FI_FLAG_ORPHAN_RECOVERY	0x2
+
+struct inode *cmfs_iget(struct cmfs_super *csb,
+			u64 blkno,
+			unsigned flags,
+			int sysfile_type);
+void cmfs_sync_blockdev(struct super_block *sb);
+
+
+
+static inline struct cmfs_inode_info *CMFS_I(struct inode *inode)
+{
+	return container_of(inode, struct cmfs_inode_info, vfs_inode);
+}
+
+#endif /* CMFS_INODE_H */
Index: linux-cmfs/fs/cmfs/journal.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/journal.h
@@ -0,0 +1,82 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * journal.h
+ *
+ * Defines journalling api and structures.
+ * (Copied and modified from fs/ocfs2/journal.h)
+ *
+ * Copyright (C) 2003, 2005 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_JOURNAL_H
+#define CMFS_JOURNAL_H
+
+#include <linux/fs.h>
+#include <linux/jbd2.h>
+
+enum cmfs_journal_state {
+	CMFS_JOURNAL_FREE = 0,
+	CMFS_JOURNAL_LOADED,
+	CMFS_JOURNAL_IN_SHUTDOWN,
+};
+
+struct cmfs_super;
+struct cmfs_dinode;
+
+struct cmfs_journal {
+	enum cmfs_journal_state	j_state;
+	journal_t                 *j_journal; /* The kernels journal type */
+	struct inode              *j_inode;   /* Kernel inode pointing to
+					       * this journal             */
+	struct cmfs_super        *j_csb;     /* pointer to the super
+					       * block for the node
+					       * we're currently
+					       * running on -- not
+					       * necessarily the super
+					       * block from the node
+					       * which we usually run
+					       * from (recovery,
+					       * etc)                     */
+	struct buffer_head        *j_bh;      /* Journal disk inode block */
+	atomic_t                  j_num_trans; /* Number of transactions
+						* currently in the system. */
+	spinlock_t                j_lock;
+	unsigned long             j_trans_id;
+	struct rw_semaphore       j_trans_barrier;
+	wait_queue_head_t         j_checkpointed;
+
+	/* both fields protected by j_lock*/
+	struct list_head          j_la_cleanups;
+	struct work_struct        j_recovery_work;
+};
+
+
+int cmfs_check_journal(struct cmfs_super *csb);
+void cmfs_complete_recovery(struct work_struct *work);
+int cmfs_journal_init(struct cmfs_journal *jouranl, int *dirty);
+int cmfs_journal_wipe(struct cmfs_journal *journal, int full);
+int cmfs_journal_load(struct cmfs_journal *journal, int replayed);
+void cmfs_journal_shutdown(struct cmfs_super *csb);
+void cmfs_complete_mount_recovery(struct cmfs_super *csb);
+void cmfs_recovery_exit(struct cmfs_super *csb);
+
+
+
+#endif /* CMFS_JOURNAL_H */
Index: linux-cmfs/fs/cmfs/localalloc.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/localalloc.h
@@ -0,0 +1,37 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * localalloc.h
+ *
+ * Function prototypes
+ * (Copied and modified from fs/ocfs2/localalloc.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_LOCALALLOC_H
+#define CMFS_LOCALALLOC_H
+
+void cmfs_la_set_sizes(struct cmfs_super *osb, int requested_mb);
+void cmfs_la_enable_worker(struct work_struct *work);
+int cmfs_begin_local_alloc_recovery(struct cmfs_super *csb,
+				    struct cmfs_dinode **alloc_copy);
+int cmfs_load_local_alloc(struct cmfs_super *csb);
+void cmfs_shutdown_local_alloc(struct cmfs_super *csb);
+#endif /* CMFS_LOCALALLOC_H */
Index: linux-cmfs/fs/cmfs/sysfile.h
===================================================================
--- /dev/null
+++ linux-cmfs/fs/cmfs/sysfile.h
@@ -0,0 +1,33 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * sysfile.h
+ *
+ * Function prototypes
+ * (Copied and modified from fs/cofs2/sysfile.h)
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ * CMFS modification, Copyright (C) 2013, Coly Li <i@coly.li>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef CMFS_SYSFILE_H
+#define CMFS_SYSFILE_H
+
+struct inode *cmfs_get_system_file_inode(struct cmfs_super *csb, int type);
+
+#endif /* CMFS_SYSFILE_H */
